\subsection{B-splines and Spline Functions \label{sec:b-splines-spline-functions}}

We present here relevant background on B-splines for clarity and to define the
notation used throughout this manuscript.  de Boor's algorithm for generating
B-splines is given in Definition~\ref{def:bsplines}.

\begin{Definition}[B-spline]
  \label{def:bsplines}
  The $j^{th}$ B-spline of order $k$ (degree $k - 1$), for the non-decreasing
  knot sequence $\bs{\xi} = \left\{\xi_j \right\}$ is a piece-wise polynomial,
  of order $k,$ defined by the recursive relationship:
  \begin{equation}
    \label{eq:b-spline-recursion}
    B_{j,k,\bs{\xi}} \left( x \right) = 
    \lambda_{j, k, \bs{\xi}} \left( x \right) B_{j, k-1} \left( x \right) + 
    \left(1 - \lambda_{j + 1, k, \bs{\xi}} \left(x \right) \right) B_{j + 1, k -
    1, \bs{\xi}} \left(x \right),
  \end{equation}
  where
  \begin{equation}
    \label{eq:b-spline-recursion-null}
    B_{j, 1, \bs{\xi}}\left(x \right) = 1_{ \left[ \xi_{j}, \xi_{j + 1} \right)
    } \left(x\right) = 
    \begin{cases}
      1 & \xi_j \leq x < \xi_{j+1} \\
      0 & \text{otherwise}
    \end{cases},
  \end{equation}
  and
  \begin{equation}
    \label{eq:lambda}
    \lambda_{j, k, \bs{\xi}} \left(x\right) = \frac{x - \xi_{j}} {\xi_{j + k - 1}
    - \xi_{j}}.  
  \end{equation}
\end{Definition}

B-splines form a partition of unity over the range of $\bs{\xi}.$  As such, it
is advisable and common \citep[pg 99]{deboor2001} to set the, $k$-fold boundary
knots at $\min x$ and $\max x$ respectively. An additional $l$ knots can be
placed within the range of $x.$

\begin{Definition}[Knot Sequence]
  \label{def:knot_sequence}
  The knot sequence, $\bs{\xi} = \left\{ \xi_i \right\}_{i = 1}^{2k+l},$ is a
  non-decreasing sequence with $l$ interior knots and $k$-fold boundary
  knots.  
  \[\min x = \underbrace{\xi_1 = \cdots = \xi_k}_{\text{boundary knots}} < 
    \underbrace{\xi_{k + 1} < \cdots < \xi_{k + l}}_{\text{interior knots}} <
  \underbrace{\xi_{k + l + 1} = \cdots = \xi_{2k + l}}_{\text{boundary knots}} = \max x.\] 
\end{Definition}

The B-splines, also called basis functions, create the foundation for a {\it
spline space}.  Linear combinations of B-splines create {\itshape spline
functions}.  For ease, the collection of B-splines are represented in matrix
notation.

\begin{Definition}[Spline Space]
  \label{def:spline_space}
  For a given knot sequence $\bs{\xi}$, the collection of all $k^{th}$ order
  spline functions define a {\it spline space}
  \begin{equation}
    \label{eq:spline_space}
    \mathbb{S}_{k, \bs{\xi}} = \text{span}\ \bs{B}_{k, \bs{\xi}}.
  \end{equation}
  $\bs{B}_{k, \bs{\xi}} \in \mathbb{R}^{\card{ \bs{x} } \times \left( k + l\right)}$ is defined as
  \begin{equation}
    \label{eq:b-matrix}
    \bs{B}_{k, \bs{\xi}} \left( \bs{x} \right) = 
    \begin{bmatrix}
      B_{1,k, \bs{\xi}}\left( x_{1} \right) & B_{2,k, \bs{\xi}}\left( x_{1} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{1} \right) \\
      B_{1,k, \bs{\xi}}\left( x_{2} \right) & B_{2,k, \bs{\xi}}\left( x_{2} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{2} \right) \\
      \vdots & \vdots & \ddots & \vdots \\
      B_{1,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) & B_{2,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) 
    \end{bmatrix}
  \end{equation}
\end{Definition}

{\tt R} comes with the \pkg{splines} package with includes the function
\code{bs} for generating the basis matrix for B-splines.  The \pkg{cpr} package
provides another function \code{bsplines} to generate B-splines, but with
different \code{attributes} which are key in the control polygon reduction
methods.

<<>>=
# Construct a B-spline Basis using the splines package.
args(splines::bs)
bmat_splines <- 
  splines::bs(x = 1:100, knots = c(20, 70), intercept = TRUE)

# Construct the same Basis using the cpr package.
args(cpr::bsplines)
bmat_cpr <- 
  cpr::bsplines(x = 1:100, iknots = c(20, 70))

# Same matrix, save attributes?
all.equal(target           = unclass(bmat_cpr),
          current          = unclass(bmat_splines),
          check.attributes = FALSE)
@

The basis matrix is same from either function.  The \pkg{cpr} version has been
built and provided for the following reasons:
\begin{itemize}
  \item To generate the full basis, \code{intercept = TRUE} must be specified in
    the \code{splines::bs} call.  The default action is to omit the first
    column of the basis.  This is done so that in regression models with a
    global intercept the design matrix will be not be rank deficient.  The CPR
    algorithm requires the use of the full basis and thus having
    \code{cpr::bsplines} return the full basis be default is advantageous.

  \item \code{cpr::bsplines} has, in my opinion, a consistent naming pattern for
    the interior, \code{iknots}, and boundary, \code{bknots}, knots.

  \item The algorithms to follow are based on the \emph{order} of the B-spline,
    not the \emph{degree}.  B-splines returned by \code{cpr::bsplines} have the
    order as an attribute, not the degree as with \code{splines::bs}.

  \item The \code{cpr::bsplines} carries attributes for the full knot sequence
    $\bs{\xi}$ and for the Greville sites $\bs{\xi}^{*}$ (see B-Spline
    Property~\ref{Bsproperty:control_polygon}).
\end{itemize}

<<>>=
# compare the structure of the two matrices.
str(bmat_splines)
str(bmat_cpr)
@

Now we need to use the basis functions to model data.  Assume you have data of
the form
\begin{equation}
  \label{eq:general_data}
  \bs{y} = f\left(x\right) + \bs{X}\bs{\beta} + \bs{Z} \bs{b} + \bs{\epsilon},
\end{equation}
where the response is a function of a continuous predictor $x$ and possible
fixed effects, $\bs{X\beta},$ possible random effects $\bs{Zb},$ and measurement
error $\bs{\epsilon}.$  We are interested in modeling $f$ via B-splines.  
\begin{Definition}[Spline Functions]
  \label{def:spline_function}
  For a given knot sequence $\bs{\xi}$ a $k^{th}$ order {\it spline function}
  is a linear combination of B-splines.  
  \begin{equation}
    \label{eq:spline-function}
    \bs{B}_{k, \bs{\xi}}\left(x \right) \bs{\theta}
  \end{equation} 
  where
  $\bs{\theta} \in \mathbb{R}^{\left(k + l \right) \times 1}$ is a vector of coefficients.
\end{Definition}
We will model the function $f$ with a spline function, i.e., 
\[ f\left( x \right) \approx \bs{B}_{k, \bs{\xi}} \left(x \right) \bs{\theta}\].

Let's illustrate a basis and a spline function.  We'll address the modeling
issue later.  For this example we will work on a domain of $x \in [0, 6],$ work
with cubic (order $k = 4,$ the default) B-splines, and
set up an initial knot sequence with five internal knots as defined in the
following {\tt R} chunk.

<<basis>>= 
#cap = "Cool", fig.width = 4, fig.height = 4>>=
# Domain, five hundred observations between 0 and 6 inclusive.
xvec <- seq(0, 6, length = 500)

# Internal knots
iknots <- c(1, 1.5, 2.3, 4, 4.5)

# Define the basis matrix
bmat <- bsplines(x = xvec, iknots = iknots)

# generate the plot in Figure \ref{fig:basis} If you do not like this plot, or
# you just want to get at the data used to create it: 
# plot_data <- plot(bmat)$data
# You could also use matplot
# plot(bmat)
@


The plot in Figure~\ref{fig:basis} shows the \Sexpr{qwraps2::frmt(ncol(bmat))}
B-splines and the the location of the \Sexpr{qwraps2::frmt(length(iknots))}
internal knots.  This basis is used to generate the spline function in
Figure~\ref{fig:splinefunction} using the coefficients $\bs{\theta} = \left(1,
  0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5 \right)^T.$

<<splinefunction>>=
theta <- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
@

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.30\textwidth}
<<background_basis, echo = TRUE, fig.width = 4, fig.height = 4>>=
plot(bmat)
@
  \caption{A Basis \label{fig:basis}}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.30\textwidth}
<<background_multiplied_splines, echo = FALSE, fig.width = 4, fig.height = 4>>=
temp <- plot(bmat * matrix(theta, byrow = TRUE, nrow = length(xvec), ncol = nrow(theta)))
temp
@
  \caption{Each B-spline muliplied by its coefficient. \label{fig:basis2}}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.30\textwidth}
<<background_spline_function, echo = FALSE, fig.width = 3, fig.height = 4>>=
temp[[2]] <- NULL
dat <- data.frame(x = xvec, y = (bmat %*% theta)[, 1])
temp + geom_line(mapping = aes(x = x, y = y), 
                 data = dat, 
                 inherit.aes = FALSE)
@
  \caption{Spline Function \label{fig:basis3}}
  \end{subfigure}
  \caption{Basis, Element, Spline Function}
\end{figure}


<<>>=
# xi <- c(rep(0, 4), iknots, rep(6, 4)) 
# xi_star <- greville_sites(xi)
# theta <- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
# 
# xvec <- seq(0, 6, length = 500) 
# bmat <- bsplines(x = xvec, iknots = iknots, bknots = c(0, 6), order = 4)
# 
# 
# Bmat <- cpr::
@



