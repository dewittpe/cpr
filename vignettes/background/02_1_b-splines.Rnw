\subsection{B-splines and Spline Functions \label{sec:b-splines-spline-functions}}

We present here relevant background on B-splines for clarity and to define the
notation used throughout this manuscript.  de Boor's algorithm for generating
B-splines is given in Definition~\ref{def:bsplines}.

\begin{Definition}[B-spline]
  \label{def:bsplines}
  The $j^{th}$ B-spline of order $k$ (degree $k - 1$), for the non-decreasing
  knot sequence $\bs{\xi} = \left\{\xi_j \right\}$ is a piece-wise polynomial,
  of order $k,$ defined by the recursive relationship:
  \begin{equation}
    \label{eq:b-spline-recursion}
    B_{j,k,\bs{\xi}} \left( x \right) = 
    \lambda_{j, k, \bs{\xi}} \left( x \right) B_{j, k-1} \left( x \right) + 
    \left(1 - \lambda_{j + 1, k, \bs{\xi}} \left(x \right) \right) B_{j + 1, k -
    1, \bs{\xi}} \left(x \right),
  \end{equation}
  where
  \begin{equation}
    \label{eq:b-spline-recursion-null}
    B_{j, 1, \bs{\xi}}\left(x \right) = 1_{ \left[ \xi_{j}, \xi_{j + 1} \right)
    } \left(x\right) = 
    \begin{cases}
      1 & \xi_j \leq x < \xi_{j+1} \\
      0 & \text{otherwise}
    \end{cases},
  \end{equation}
  and
  \begin{equation}
    \label{eq:lambda}
    \lambda_{j, k, \bs{\xi}} \left(x\right) = \frac{x - \xi_{j}} {\xi_{j + k - 1}
    - \xi_{j}}.  
  \end{equation}
\end{Definition}

B-splines form a partition of unity over the range of $\bs{\xi}.$  As such, it
is advisable and common \citep[pg 99]{deboor2001} to set the, $k$-fold boundary
knots at $\min x$ and $\max x$ respectively. An additional $l$ knots can be
placed within the range of $x.$

\begin{Definition}[Knot Sequence]
  \label{def:knot_sequence}
  The knot sequence, $\bs{\xi} = \left\{ \xi_i \right\}_{i = 1}^{2k+l},$ is a
  non-decreasing sequence with $l$ interior knots and $k$-fold boundary
  knots.  
  \[\min x = \underbrace{\xi_1 = \cdots = \xi_k}_{\text{boundary knots}} < 
    \underbrace{\xi_{k + 1} < \cdots < \xi_{k + l}}_{\text{interior knots}} <
  \underbrace{\xi_{k + l + 1} = \cdots = \xi_{2k + l}}_{\text{boundary knots}} = \max x.\] 
\end{Definition}

The B-splines, also called basis functions, create the foundation for a {\it
spline space}.  Linear combinations of B-splines create {\itshape spline
functions}.  For ease, the collection of B-splines are represented in matrix
notation.

\begin{Definition}[Spline Space]
  \label{def:spline_space}
  For a given knot sequence $\bs{\xi}$, the collection of all $k^{th}$ order
  spline functions define a {\it spline space}
  \begin{equation}
    \label{eq:spline_space}
    \mathbb{S}_{k, \bs{\xi}} = \text{span}\ \bs{B}_{k, \bs{\xi}}.
  \end{equation}
  $\bs{B}_{k, \bs{\xi}} \in \mathbb{R}^{\card{ \bs{x} } \times \left( k + l\right)}$ is defined as
  \begin{equation}
    \label{eq:b-matrix}
    \bs{B}_{k, \bs{\xi}} \left( \bs{x} \right) = 
    \begin{bmatrix}
      B_{1,k, \bs{\xi}}\left( x_{1} \right) & B_{2,k, \bs{\xi}}\left( x_{1} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{1} \right) \\
      B_{1,k, \bs{\xi}}\left( x_{2} \right) & B_{2,k, \bs{\xi}}\left( x_{2} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{2} \right) \\
      \vdots & \vdots & \ddots & \vdots \\
      B_{1,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) & B_{2,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) & \cdots & B_{k+l,k, \bs{\xi}}\left( x_{\card{\bs{x}}} \right) 
    \end{bmatrix}
  \end{equation}
\end{Definition}

{\tt R} comes with the \pkg{splines} package with includes the function
\code{bs} for generating the basis matrix for B-splines.  The \pkg{cpr} package
provides another function \code{bsplines} to generate B-splines, but with
different \code{attributes} which are key in the control polygon reduction
methods.

<<background_bsplines_vs_bs>>=
# Construct a B-spline Basis using the splines package.
args(splines::bs)
bmat_splines <- 
  splines::bs(x = 1:100, knots = c(20, 70), intercept = TRUE)

# Construct the same Basis using the cpr package.
args(cpr::bsplines)
bmat_cpr <- 
  cpr::bsplines(x = 1:100, iknots = c(20, 70))

# Same matrix, save attributes?
all.equal(target           = unclass(bmat_cpr),
          current          = unclass(bmat_splines),
          check.attributes = FALSE)
@

The basis matrix is same from either function.  The \pkg{cpr} version has been
built and provided for the following reasons:
\begin{itemize}
  \item To generate the full basis, \code{intercept = TRUE} must be specified in
    the \code{splines::bs} call.  The default action is to omit the first
    column of the basis.  This is done so that in regression models with a
    global intercept the design matrix will be not be rank deficient.  The CPR
    algorithm requires the use of the full basis and thus having
    \code{cpr::bsplines} return the full basis be default is advantageous.

  \item \code{cpr::bsplines} has, in my opinion, a consistent naming pattern for
    the interior, \code{iknots}, and boundary, \code{bknots}, knots.

  \item The algorithms to follow are based on the \emph{order} of the B-spline,
    not the \emph{degree}.  B-splines returned by \code{cpr::bsplines} have the
    order as an attribute, not the degree as with \code{splines::bs}.

  \item The \code{cpr::bsplines} carries attributes for the full knot sequence
    $\bs{\xi}$ and for the Greville sites $\bs{\xi}^{*}$ (see B-Spline
    Property~\ref{Bsproperty:control_polygon}).
\end{itemize}

<<background_bmat_structure>>=
# compare the structure of the two matrices.
str(bmat_splines)
str(bmat_cpr)
@

Now we need to use the basis functions to model data.  Assume you have data of
the form
\begin{equation}
  \label{eq:general_data}
  \bs{y} = f\left(x\right) + \bs{X}\bs{\beta} + \bs{Z} \bs{b} + \bs{\epsilon},
\end{equation}
where the response is a function of a continuous predictor $x$ and possible
fixed effects, $\bs{X\beta},$ possible random effects $\bs{Zb},$ and measurement
error $\bs{\epsilon}.$  We are interested in modeling $f$ via B-splines.  
\begin{Definition}[Spline Functions]
  \label{def:spline_function}
  For a given knot sequence $\bs{\xi}$ a $k^{th}$ order {\it spline function}
  is a linear combination of B-splines.  
  \begin{equation}
    \label{eq:spline-function}
    \bs{B}_{k, \bs{\xi}}\left(x \right) \bs{\theta}
  \end{equation} 
  where
  $\bs{\theta} \in \mathbb{R}^{\left(k + l \right) \times 1}$ is a vector of coefficients.
\end{Definition}
We will model the function $f$ with a spline function, i.e., 
\[ f\left( x \right) \approx \bs{B}_{k, \bs{\xi}} \left(x \right) \bs{\theta}.\]

\paragraph{Example}
% The following R chunk is placed here with echo = FALSE so that the objects are
% in the workspace for the paragraph to follow.  The chunk is recalled, eval =
% FALSE below the paragraph so the user can see the code needed to continue the
% vignette.
<<background_example_setup, echo = FALSE>>= 
# Domain, five hundred observations between 0 and 6 inclusive.
xvec <- seq(0, 6, length = 500)

# Internal knots
iknots <- c(1, 1.5, 2.3, 4, 4.5)

# Define the basis matrix
bmat <- bsplines(x = xvec, iknots = iknots)

# Define the 
theta <- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
@

Let's illustrate a basis and a spline function.  We'll address the modeling
issue later.  For this example we will work on a domain of $x \in
[\Sexpr{paste(range(xvec), collapse = ", ")}]$ work with cubic (order $k = 4,$
the default) B-splines, and set up an initial knot sequence with five internal
knots.  For this example we'll use the knot sequcence and coefficient vector
\begin{equation}
  \label{eq:background_example_setup}
  \begin{array}{c}
  \bs{\xi} = \left\{ \Sexpr{paste(formatC(attr(bmat, "xi"), digits = 1, format =
"f"), collapse = ", ")} \right\} \\ \text{and} \\
\bs{\theta} = \left(
  \Sexpr{paste(formatC(theta, digits = 1, format = "f"), collapse = ", ")}
\right)^T.
\end{array}
\end{equation}

The plot in Figure~\ref{fig:basis_and_spline_function_a} shows the
\Sexpr{ncol(bmat)} B-splines and the the location of the \Sexpr{length(iknots)}
internal knots.  Multiplying each of the B-splines by its respective coefficient
creates
Figure~\ref{fig:basis_and_spline_function_b}.  Finally, 
Figure~\ref{fig:basis_and_spline_function_c} shows the spline function
$\bs{B}_{k = 4, \bs{\xi}} \left( x \right) \bs{\theta}.$  

The following R chunks
are provided to show the user how this example was set up and how the plots are
created.  There is an S3 plotting method for \code{cpr\_bs} objects, i.e., the
\code{bmat}.  That plotting function returns a \code{ggplot} and can be
explotied as such.

<<>>=
<<background_example_setup, eval = FALSE>>=
@

<<background_basis, echo = TRUE, eval = FALSE>>=
# generate Figure \ref{fig:basis_and_spline_function_a}
plot(bmat) + 
  ggplot2::theme(legend.position = c(0.7, 0.85)) + 
  ggplot2::guides(col = ggplot2::guide_legend(nrow = 3))

@ 
<<background_multiplied_splines, echo = TRUE, eval = FALSE>>=
# generate Figure \ref{fig:basis_and_spline_function_b}
# multiple each spline (column of bmat) by its coef we store the plot as `plotb`
# as it will be reused to build Figure \ref{fig:basis_and_spline_function_c}.
bmat2 <- 
  bmat * matrix(theta, byrow = TRUE, nrow  = length(xvec), ncol  = nrow(theta))

plotb <- plot(bmat2) + ggplot2::theme(legend.position = "none") 
plotb
@ 
<<background_spline_function, echo = TRUE, eval = FALSE>>=
# generate Figure \ref{fig:basis_and_spline_function_c}
# remove the layers from `plotb`, this is a trick to keep the same axis text
# from each plot when the class of the object to plot changes.
plotb[[which(names(plotb) == "layers")]] <- NULL

# construct a data.frame for the spline function
dat <- data.frame(x = xvec, y = (bmat %*% theta)[, 1])

# plot the spline function
plotb + geom_line(mapping = aes(x = x, y = y), data = dat, inherit.aes = FALSE)
@

\begin{figure}
  \centering
  \begin{subfigure}[t]{0.30\textwidth}
<<>>=
<<background_basis, echo = FALSE, fig.width = 4, fig.height = 4>>=
@
  \caption{The B-splines, $B_{j, k, \bs{\xi}},$ forming a basis.\label{fig:basis_and_spline_function_a}}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.30\textwidth}
<<>>=
<<background_multiplied_splines, echo = FALSE, fig.width = 4, fig.height = 4>>=
@
  \caption{Each B-spline muliplied by its coefficient, e.g, $\theta_1 B_{1, k,
    \bs{\xi}} \left( x \right).$
  \label{fig:basis_and_spline_function_b}}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.30\textwidth}
<<>>=
<<background_spline_function, echo = FALSE, fig.width = 4, fig.height = 4>>=
@
  \caption{The spline function $\bs{B}_{k, \bs{\xi}}\left( x \right) \bs{\theta}.$ \label{fig:basis_and_spline_function_c}}
  \end{subfigure}
  \caption{basis, elementwise multiplication, and the spline function.  These
    graphics are for standard cubic (order $k = 4$) B-splines with knot sequence
    $\bs{\xi}$ and coefficients $\bs{\theta}$ as defined in
    \eqref{eq:background_example_setup}.
  \label{fig:basis_and_spline_function}}
\end{figure}

The relationship between any particular knot, coefficient, and the
resulting spline function is not, at least to me, evidient form the plots in
Figure~\ref{fig:basis_and_spline_function}.  However, there is a meaningful
relationship between the knot sequence, $\bs{\xi},$ and the coefficient vector
$\bs{\theta}:$ the control polygon.  
